package com.gambling.betting_odds_api.service;
// Internal project imports
import com.gambling.betting_odds_api.dto.AuthResponse;      // Authentication response DTO
import com.gambling.betting_odds_api.dto.LoginRequest;      // Login request DTO
import com.gambling.betting_odds_api.dto.RegisterRequest;   // Registration request DTO
import com.gambling.betting_odds_api.model.User;            // User entity
import com.gambling.betting_odds_api.repository.UserRepository; // User data access
import com.gambling.betting_odds_api.security.JwtTokenProvider; // JWT token operations
// Spring Framework - Security and dependency injection
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; // Password hashing
import org.springframework.stereotype.Service;                           // Marks class as service layer
// Lombok - Reduces boilerplate code
import lombok.RequiredArgsConstructor; // Constructor injection for final fields
import lombok.extern.slf4j.Slf4j;      // Logger instance
/**
AuthService - Business logic for user authentication and registration.
Responsibilities:
User registration (with validation and password hashing)
User login (with credential validation)
JWT token generation for authenticated users
Security checks (duplicate users, invalid credentials)
Security Flow:
Register: username/email uniqueness → hash password → save user → generate JWT
Login: find user → verify password → check active status → generate JWT
Dependencies (injected via constructor):
UserRepository: Database operations for users
BCryptPasswordEncoder: Password hashing and verification
JwtTokenProvider: JWT token generation and validation
Note: Exceptions are currently basic (IllegalArgumentException, RuntimeException).
  In Phase 4, we'll create custom exceptions for better error handling.
*/
@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {
// Dependencies injected via constructor (final + @RequiredArgsConstructor)
private final UserRepository userRepository;
private final BCryptPasswordEncoder passwordEncoder;
private final JwtTokenProvider jwtTokenProvider;

/**
 * Register a new user.
 * 
 * Process:
 *   1. Validate username uniqueness (throws if exists)
 *   2. Validate email uniqueness (throws if exists)
 *   3. Hash password with BCrypt (never store plain text!)
 *   4. Create and save User entity (with default role=USER, active=true)
 *   5. Generate JWT token for immediate login
 *   6. Return AuthResponse with token and user info
 * 
 * Security Notes:
 *   - Password is hashed with BCrypt (60-character hash with salt)
 *   - Default role is USER (not ADMIN or BOOKMAKER)
 *   - Account is active by default
 *   - Timestamps (createdAt, updatedAt) are auto-generated by @PrePersist
 * 
 * @param request RegisterRequest containing username, email, password
 * @return AuthResponse with JWT token and user details
 * @throws IllegalArgumentException if username or email already exists
 */
public AuthResponse register(RegisterRequest request) {
    log.info("Attempting to register new user: {}", request.getUsername());

    // STEP 1: Check if username already exists
    // Why: Usernames must be unique (database constraint)
    if (userRepository.existsByUsername(request.getUsername())) {
        log.warn("Registration failed: Username '{}' already exists", request.getUsername());
        throw new IllegalArgumentException("Username already exists");
    }

    // STEP 2: Check if email already exists
    // Why: Emails must be unique (database constraint + account recovery)
    if (userRepository.existsByEmail(request.getEmail())) {
        log.warn("Registration failed: Email '{}' already exists", request.getEmail());
        throw new IllegalArgumentException("Email already exists");
    }

    // STEP 3: Hash password with BCrypt
    // Why: NEVER store plain text passwords! BCrypt adds salt and hashes.
    // Example: "password123" → "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy"
    String hashedPassword = passwordEncoder.encode(request.getPassword());
    log.debug("Password hashed successfully for user: {}", request.getUsername());

    // STEP 4: Create User entity
    // Why: Builder pattern creates immutable object with all required fields
    // Note: role=USER and active=true are set by @Builder.Default in User entity
    User user = User.builder()
            .username(request.getUsername())
            .email(request.getEmail())
            .password(hashedPassword)
            // role and active are set to defaults (USER, true)
            .build();

    // STEP 5: Save user to database
    // Why: Persist user data and get auto-generated ID
    // Note: @PrePersist sets createdAt and updatedAt timestamps
    User savedUser = userRepository.save(user);
    log.info("User registered successfully: {} (ID: {})", savedUser.getUsername(), savedUser.getId());

    // STEP 6: Generate JWT token
    // Why: User is logged in immediately after registration (better UX)
    String token = jwtTokenProvider.generateToken(savedUser.getUsername());
    log.debug("JWT token generated for new user: {}", savedUser.getUsername());

    // STEP 7: Build and return AuthResponse
    // Why: Client needs token to authenticate future requests
    return AuthResponse.builder()
            .token(token)
            .tokenType("Bearer")
            .username(savedUser.getUsername())
            .email(savedUser.getEmail())
            .role(savedUser.getRole())
            .build();
}

/**
 * Authenticate existing user and generate JWT token.
 * 
 * Process:
 *   1. Find user by username (throws if not found)
 *   2. Check if account is active (throws if disabled)
 *   3. Verify password with BCrypt (throws if incorrect)
 *   4. Generate JWT token
 *   5. Return AuthResponse with token and user info
 * 
 * Security Notes:
 *   - Password is compared using BCrypt.matches() (secure comparison)
 *   - Inactive accounts cannot login (soft delete support)
 *   - Token is generated only after successful authentication
 *   - No information leakage (same error for invalid user/password)
 * 
 * @param request LoginRequest containing username and password
 * @return AuthResponse with JWT token and user details
 * @throws RuntimeException if credentials are invalid or account is inactive
 */
public AuthResponse login(LoginRequest request) {
    log.info("Login attempt for user: {}", request.getUsername());

    // STEP 1: Find user by username
    // Why: We need user data to verify password and generate token
    // Note: Optional.orElseThrow() throws if user doesn't exist
    User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> {
                log.warn("Login failed: User '{}' not found", request.getUsername());
                return new RuntimeException("Invalid username or password");
            });

    // STEP 2: Check if account is active
    // Why: Disabled accounts (active=false) should not be able to login
    // Use case: Admin can disable suspicious accounts
    if (!user.getActive()) {
        log.warn("Login failed: User '{}' account is inactive", request.getUsername());
        throw new RuntimeException("Account is inactive");
    }

    // STEP 3: Verify password
    // Why: Authenticate user by comparing provided password with stored hash
    // How: BCrypt.matches() hashes input password and compares with stored hash
    // Security: Timing-safe comparison (prevents timing attacks)
    if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
        log.warn("Login failed: Invalid password for user '{}'", request.getUsername());
        throw new RuntimeException("Invalid username or password");
    }

    log.info("User authenticated successfully: {}", user.getUsername());

    // STEP 4: Generate JWT token
    // Why: Token is used for authentication in subsequent requests
    // Note: Token contains username and expiration time (signed with secret)
    String token = jwtTokenProvider.generateToken(user.getUsername());
    log.debug("JWT token generated for user: {}", user.getUsername());

    // STEP 5: Build and return AuthResponse
    // Why: Client needs token and user info for UI and API calls
    return AuthResponse.builder()
            .token(token)
            .tokenType("Bearer")
            .username(user.getUsername())
            .email(user.getEmail())
            .role(user.getRole())
            .build();
}
}